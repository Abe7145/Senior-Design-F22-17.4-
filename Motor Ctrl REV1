#include <Wire.h>
#include <Adafruit_MotorShield.h>


// Connect to the two encoder pin
#define ENCODER_A   2
#define ENCODER_B   5


// This program uses a state machine to track the encoderâ€™s position
// These variables store the state
bool A_LAST_STATE = 0;
bool A_CURRENT_STATE = 0;
bool B_CURRENT_STATE = 0;


// Create the motor shield object with the default I2C address
Adafruit_MotorShield AFMS = Adafruit_MotorShield();
// And connect a DC motor to port M1
Adafruit_DCMotor *myMotor = AFMS.getMotor(1);


int count; // measures motor encoder counts -- unitless
int intError = 0; //integral error for I in PI controller -- tenths of a degree second       
int prevMyTime = 0; //previous loop time marker -- milliseconds 
int currMyTime = 0; //current time marker -- milliseconds 
int prev_pos = 0; // stores the position of the motor in the previous loop -- position in degrees
int target = 30; // target position -- position in degrees
double motorVal = 0;//variable to hold the value we write to the motor -- units in degrees
double current_pos = 0; // current position of the motor -- position in degrees

// Proportional controller constants
const double Ki = 0.01;
const double Kp = 3.5;

void setup() {

  // Encoder pins
  pinMode(ENCODER_A, INPUT);
  pinMode(ENCODER_B, INPUT);

  Serial.begin(9600);

  A_LAST_STATE = digitalRead(ENCODER_A);
  
  // Setting up the interrupt handler 
  // Activates whenever the CLK pin on the encoder changes voltage
  attachInterrupt(digitalPinToInterrupt(ENCODER_A), TICK, CHANGE); 

  delay(100);
  //if (!AFMS.begin()) {         // create with the default frequency 1.6KHz
  if (!AFMS.begin(1000)) {  // OR with a different frequency, say 1KHz
    Serial.println("Could not find Motor Shield. Check wiring.");
    while (1);
  }
  Serial.println("Motor Shield found.");  Serial.println("Begun");
  // turn on motor M1
  //myMotor->setSpeed(0);
  
  
}

void loop() {

  // Normalizing the unitless encoder counts into a 360 degree rotation
  current_pos = double(count)/8.88;//2.22

  
  if (current_pos-target <=  10 && current_pos-target >=  -10){// THIS IF STATEMENT IS SUPER DUPER IMPORTANT!!!!!!!!!!!!
    current_pos = target;                // There is some noise in the system that will cause everything to become unstable
    intError = 0;                         // This if statement rejects such noise and keeps the system from running away
  }
  
  currMyTime = millis();//get current time
  if (currMyTime >= prevMyTime+100){ // sample every 10th of a second

    // calculating integral error
    intError += (current_pos-target);

    // storing dt
    prev_pos = current_pos;//reset prev_pos
    prevMyTime = currMyTime;//reset prevMyTime

    // use built in shield library to move the motor 
    // takes in values from -400 to 400
    // uses a built in PWM to control the voltage supplied to the motor
    motorVal = double(( target-current_pos )) * Kp + (Ki * double(intError)); //calculate the motor val
    //md.setM1Speed( motorVal );

    motorVal *= 255/400; //normalize to 0-255 for adafruit
    Serial.print("motorVal: ");
    Serial.println(motorVal);
    myMotor->run(FORWARD);
    myMotor->setSpeed(motorVal);
  }

}

// Encoder interrupt
void TICK() {
  //Serial.print("here");
  // Normalize values over 360 degrees into values from 0-360
  if ( count >= 3200 ) {

    count = 0;
  }

  A_CURRENT_STATE = digitalRead(ENCODER_A);//read state of signal A
  B_CURRENT_STATE = digitalRead(ENCODER_B);//read state of signal B

  if (A_CURRENT_STATE != A_LAST_STATE){
    if (A_CURRENT_STATE==B_CURRENT_STATE){ //if the signals are the same
  
      count-=1;//subract from the count
    }
    else {//if signals are different
      count+=1;//add 2 to the count
    }
     Serial.print( A_CURRENT_STATE );
     Serial.print( "  " );
     Serial.print( B_CURRENT_STATE );
     Serial.print( '\n' );
  }
}
